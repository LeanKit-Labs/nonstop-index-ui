const gulp = require( "gulp" );
const file = require( "gulp-file" );
const glob = require( "glob" );
const argv = require( "yargs" ).argv;
const _ = require( "lodash" );
const karma = require( "karma" );
const NODE_SUCCESS_EXIT_CODE = 0;

gulp.task( "test:build-karma-index", () => {
	let karmaIndex = [
		"// HEADS UP! THIS FILE IS AUTO-GENERATED BY THE 'test:build-karma-index' gulp task.",
		"",
		"require( \"./helpers/phantomjs-shims.js\" );",
		"require( \"./helpers/setup.js\" );"
	];

	if ( argv.single ) {
		karmaIndex.push( `require( "./${ argv.single }" );` );
	} else {
		karmaIndex = karmaIndex.concat(
			glob.sync( argv.grep ? argv.grep : "**/*.spec.js*", { cwd: "./client/spec" } ).map( fileName => {
				return `require( "./${ fileName }" );`;
			} )
		);
	}

	return file( "karma-index.js", karmaIndex.join( "\n" ), { src: true } )
		.pipe( gulp.dest( "./client/spec" ) );
} );

function runTests( options, done ) {
	const server = new karma.Server( _.extend( {
		configFile: `${ appConfig.root }/karma.conf.js`,
		singleRun: true

		// no-op keeps karma from process.exit'ing gulp
	}, options ), done || function() {} ); // eslint-disable-line prefer-arrow-callback

	server.start();
}

gulp.task( "karma-test-ci", [ "webpack:watch", "webpack:test" ], () => {
	gulp.watch( [ "client/spec/**/*.js*", "!client/spec/karma-index.js" ], event => {
		if ( event.type === "added" || event.type === "deleted" ) {
			gulp.run( "test:build-karma-index" );
		}
	} );

	runTests( {
		autoWatch: true,
		singleRun: false,
		client: {
			mocha: {
				bail: true
			}
		}
	} );
} );

gulp.task( "karma-test", [ "webpack:test" ], done => {
	// There are issues with the osx reporter keeping
	// the node process running, so this forces the main
	// test task to not show errors in a notification
	runTests( { reporters: [ "spec" ] }, err => {
		if ( err === NODE_SUCCESS_EXIT_CODE ) {
			done( null );
		} else {
			// Exit with the error code
			process.exit( err ); // eslint-disable-line no-process-exit
		}
	} );
} );

const gulpMocha = require( "gulp-spawn-mocha" );

function runMocha( singleRun ) {
	return gulp.src( "./_spec-tmp/js/test.js", { read: false } )
		.pipe( gulpMocha( {
			R: "spec",
			r: [
				"./client/spec/helpers/node-setup.js"
			]
		} ) ).on( "error", () => {
			if ( singleRun ) {
				process.exit( 1 ); // eslint-disable-line no-process-exit
			}
		} );
}

const SPEC_CI_DEBOUNCE_DELAY = 200;
gulp.task( "node-test-ci", [ "webpack:watch", "webpack:test" ], () => {
	gulp.watch( "./_spec-tmp/js/test.js", _.debounce( () => {
		runMocha( false );
	}, SPEC_CI_DEBOUNCE_DELAY ) );
	return runMocha();
} );

gulp.task( "node-test", [ "webpack:test" ], () => runMocha( true ) );

gulp.task( "test", [ "karma-test" ] );
gulp.task( "test-ci", [ "karma-test-ci" ] );

gulp.task( "coverage", [ "webpack:coverage" ], done => {
	// There are issues with the osx reporter keeping
	// the node process running, so this forces the main
	// test task to not show errors in a notification
	runTests( { reporters: [ "progress", "coverage" ] }, err => {
		if ( err === NODE_SUCCESS_EXIT_CODE ) {
			done( null );
		} else {
			// Exit with the error code
			process.exit( err ); // eslint-disable-line no-process-exit
		}
	} );
} );
